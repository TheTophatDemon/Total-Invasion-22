// Code is generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
)
type BodiesIter struct {
	iterPlayers scene.StorageIter[Player]
	iterEnemies scene.StorageIter[Enemy]
	iterChickens scene.StorageIter[Chicken]
	iterWalls scene.StorageIter[Wall]
	iterProps scene.StorageIter[Prop]
	iterProjectiles scene.StorageIter[Projectile]
	iterItems scene.StorageIter[Item]
	iterGameMaps scene.StorageIter[comps.Map]
	storageIndex int
}

func (iter *BodiesIter) Next() (comps.HasBody, scene.Handle) {
	if iter == nil {
		return nil, scene.Handle{}
	}
	for ; iter.storageIndex < 8; iter.storageIndex++ {
		switch iter.storageIndex {
			case 0:
				item, handle := iter.iterPlayers.Next()
				if item != nil {
					return item, handle
				}
			case 1:
				item, handle := iter.iterEnemies.Next()
				if item != nil {
					return item, handle
				}
			case 2:
				item, handle := iter.iterChickens.Next()
				if item != nil {
					return item, handle
				}
			case 3:
				item, handle := iter.iterWalls.Next()
				if item != nil {
					return item, handle
				}
			case 4:
				item, handle := iter.iterProps.Next()
				if item != nil {
					return item, handle
				}
			case 5:
				item, handle := iter.iterProjectiles.Next()
				if item != nil {
					return item, handle
				}
			case 6:
				item, handle := iter.iterItems.Next()
				if item != nil {
					return item, handle
				}
			case 7:
				item, handle := iter.iterGameMaps.Next()
				if item != nil {
					return item, handle
				}
		}
	}
	return nil, scene.Handle{}
}

func (world *World) IterBodies() BodiesIter {
	return BodiesIter {
		iterPlayers: world.Players.Iter(),
		iterEnemies: world.Enemies.Iter(),
		iterChickens: world.Chickens.Iter(),
		iterWalls: world.Walls.Iter(),
		iterProps: world.Props.Iter(),
		iterProjectiles: world.Projectiles.Iter(),
		iterItems: world.Items.Iter(),
		iterGameMaps: world.GameMaps.Iter(),
		storageIndex: 0,
	}
}
type ActorsIter struct {
	iterPlayers scene.StorageIter[Player]
	iterEnemies scene.StorageIter[Enemy]
	iterChickens scene.StorageIter[Chicken]
	storageIndex int
}

func (iter *ActorsIter) Next() (HasActor, scene.Handle) {
	if iter == nil {
		return nil, scene.Handle{}
	}
	for ; iter.storageIndex < 3; iter.storageIndex++ {
		switch iter.storageIndex {
			case 0:
				item, handle := iter.iterPlayers.Next()
				if item != nil {
					return item, handle
				}
			case 1:
				item, handle := iter.iterEnemies.Next()
				if item != nil {
					return item, handle
				}
			case 2:
				item, handle := iter.iterChickens.Next()
				if item != nil {
					return item, handle
				}
		}
	}
	return nil, scene.Handle{}
}

func (world *World) IterActors() ActorsIter {
	return ActorsIter {
		iterPlayers: world.Players.Iter(),
		iterEnemies: world.Enemies.Iter(),
		iterChickens: world.Chickens.Iter(),
		storageIndex: 0,
	}
}
type LinkablesIter struct {
	iterWalls scene.StorageIter[Wall]
	iterTriggers scene.StorageIter[Trigger]
	iterCameras scene.StorageIter[Camera]
	storageIndex int
}

func (iter *LinkablesIter) Next() (Linkable, scene.Handle) {
	if iter == nil {
		return nil, scene.Handle{}
	}
	for ; iter.storageIndex < 3; iter.storageIndex++ {
		switch iter.storageIndex {
			case 0:
				item, handle := iter.iterWalls.Next()
				if item != nil {
					return item, handle
				}
			case 1:
				item, handle := iter.iterTriggers.Next()
				if item != nil {
					return item, handle
				}
			case 2:
				item, handle := iter.iterCameras.Next()
				if item != nil {
					return item, handle
				}
		}
	}
	return nil, scene.Handle{}
}

func (world *World) IterLinkables() LinkablesIter {
	return LinkablesIter {
		iterWalls: world.Walls.Iter(),
		iterTriggers: world.Triggers.Iter(),
		iterCameras: world.Cameras.Iter(),
		storageIndex: 0,
	}
}
