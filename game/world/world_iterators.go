// Code generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	"iter"
	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
)

func (world *World) AllBodies() iter.Seq2[scene.Handle, comps.HasBody] {
	return func(yield func(scene.Handle, comps.HasBody) bool) {
		nextPlayers, stop := iter.Pull2(world.Players.All())
		defer stop()
		for handle, ent, ok := nextPlayers(); ok; handle, ent, ok = nextPlayers() {
			if !yield(handle, ent) {
				return
			}
		}
		nextEnemies, stop := iter.Pull2(world.Enemies.All())
		defer stop()
		for handle, ent, ok := nextEnemies(); ok; handle, ent, ok = nextEnemies() {
			if !yield(handle, ent) {
				return
			}
		}
		nextChickens, stop := iter.Pull2(world.Chickens.All())
		defer stop()
		for handle, ent, ok := nextChickens(); ok; handle, ent, ok = nextChickens() {
			if !yield(handle, ent) {
				return
			}
		}
		nextWalls, stop := iter.Pull2(world.Walls.All())
		defer stop()
		for handle, ent, ok := nextWalls(); ok; handle, ent, ok = nextWalls() {
			if !yield(handle, ent) {
				return
			}
		}
		nextProps, stop := iter.Pull2(world.Props.All())
		defer stop()
		for handle, ent, ok := nextProps(); ok; handle, ent, ok = nextProps() {
			if !yield(handle, ent) {
				return
			}
		}
		nextProjectiles, stop := iter.Pull2(world.Projectiles.All())
		defer stop()
		for handle, ent, ok := nextProjectiles(); ok; handle, ent, ok = nextProjectiles() {
			if !yield(handle, ent) {
				return
			}
		}
		nextGameMap, stop := iter.Pull2(world.GameMap.All())
		defer stop()
		for handle, ent, ok := nextGameMap(); ok; handle, ent, ok = nextGameMap() {
			if !yield(handle, ent) {
				return
			}
		}
	}
}

func (world *World) AllActors() iter.Seq2[scene.Handle, HasActor] {
	return func(yield func(scene.Handle, HasActor) bool) {
		nextPlayers, stop := iter.Pull2(world.Players.All())
		defer stop()
		for handle, ent, ok := nextPlayers(); ok; handle, ent, ok = nextPlayers() {
			if !yield(handle, ent) {
				return
			}
		}
		nextEnemies, stop := iter.Pull2(world.Enemies.All())
		defer stop()
		for handle, ent, ok := nextEnemies(); ok; handle, ent, ok = nextEnemies() {
			if !yield(handle, ent) {
				return
			}
		}
		nextChickens, stop := iter.Pull2(world.Chickens.All())
		defer stop()
		for handle, ent, ok := nextChickens(); ok; handle, ent, ok = nextChickens() {
			if !yield(handle, ent) {
				return
			}
		}
	}
}

func (world *World) AllLinkables() iter.Seq2[scene.Handle, Linkable] {
	return func(yield func(scene.Handle, Linkable) bool) {
		nextTriggers, stop := iter.Pull2(world.Triggers.All())
		defer stop()
		for handle, ent, ok := nextTriggers(); ok; handle, ent, ok = nextTriggers() {
			if !yield(handle, ent) {
				return
			}
		}
	}
}
