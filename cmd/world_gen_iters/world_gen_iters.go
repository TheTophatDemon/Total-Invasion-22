package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path"
	"reflect"
	"strings"
	"text/template"

	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
	"tophatdemon.com/total-invasion-ii/game/world"
)

const ITERATOR_FUNCTION_TEMPLATE = `// Code is generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	"iter"
	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
)
{{ range .Iterators }}
func (world *World) {{ .MethodName }}() iter.Seq2[scene.Handle, {{.TypeName}}] {
	return func(yield func(scene.Handle, {{.TypeName}}) bool) {
		{{- range .StorageNames}}
		next{{.}}, stop := iter.Pull2(world.{{.}}.All())
		defer stop()
		for handle, ent, ok := next{{.}}(); ok; handle, ent, ok = next{{.}}() {
			if !yield(handle, ent) {
				return
			}
		}
		{{- end }}
	}
}
{{ end }}`

type IterParams struct {
	TypeName     string // Must be qualified with the package name
	MethodName   string
	StorageNames []string
}

const WORLD_PKG = "world"
const SCENE_PKG = "scene"
const OUT_PATH = "./world_iterators.go" // This will be relative to the file in which the go:generate comment is.

var verboseFlag bool

func verbosePrintfln(format string, payload ...any) {
	if verboseFlag {
		fmt.Printf(format, payload...)
		fmt.Println()
	}
}

func genIterParamsFor[Interface any](methodName string) (params IterParams) {
	worldType := reflect.TypeFor[world.World]()
	interfaceType := reflect.TypeFor[Interface]()
	storageOpsType := reflect.TypeFor[scene.StorageOps]()
	pkgName := path.Base(interfaceType.PkgPath())

	params = IterParams{
		MethodName:   methodName,
		StorageNames: make([]string, 0, worldType.NumField()),
		TypeName:     interfaceType.Name(),
	}
	if pkgName != "world" {
		params.TypeName = pkgName + "." + params.TypeName
	}

	// Find storage fields in the world struct whose inner types implement the interface.
	for f := range worldType.NumField() {
		field := worldType.Field(f)
		if !reflect.PointerTo(field.Type).Implements(storageOpsType) {
			verbosePrintfln("Field %v doesn't implement StorageOps\n", field.Name)
			continue
		}
		storageImplements := reflect.PointerTo(field.Type).Implements(interfaceType) // True if the storage itself is a member of the interface, like with GameMap
		if !storageImplements {
			if !strings.HasPrefix(field.Type.Name(), "Storage") {
				verbosePrintfln("Field %v is not a scene.Storage type. It's type is '%v'\n", field.Name, field.Type.Name())
				continue
			}

			// Get the storage struct's type parameter by looking at its data field.
			dataField, ok := field.Type.FieldByName("data")
			// Check if the pointer to the element type of the slice is a member of the interface.
			if !ok {
				verbosePrintfln("Field %v does not have a data field\n", field.Name)
				continue
			}

			if dataField.Type.Kind() != reflect.Slice {
				verbosePrintfln("Field %v's data field is not a slice, it has reflect.Kind = %v\n", field.Name, dataField.Type.Kind())
				continue
			}

			if !reflect.PointerTo(dataField.Type.Elem()).Implements(interfaceType) {
				verbosePrintfln("Field %v's data element does not implement the interface %v\n", field.Name, interfaceType.Name())
				continue
			}
		} else {
			verbosePrintfln("Field %v is itself a member of the interface %v\n", field.Name, interfaceType.Name())
		}
		params.StorageNames = append(params.StorageNames, field.Name)
	}

	return
}

func main() {
	flag.BoolVar(&verboseFlag, "verbose", false, "Print debug information about which fields get included in iterators.")
	flag.Parse()

	iterators := []IterParams{
		genIterParamsFor[comps.HasBody]("AllBodies"),
		genIterParamsFor[world.HasActor]("AllActors"),
		genIterParamsFor[world.Linkable]("AllLinkables"),
	}

	// Create output file
	outFile, err := os.Create(OUT_PATH)
	if err != nil {
		log.Fatal(err)
	}

	// Run the template on the collected data
	tmpl := template.Must(template.New("WORLD ITERATOR").Parse(ITERATOR_FUNCTION_TEMPLATE))

	tplParams := struct {
		Iterators []IterParams
	}{
		Iterators: iterators,
	}

	err = tmpl.Execute(outFile, tplParams)
	if err != nil {
		log.Fatal(err)
	}

	defer outFile.Close()
}
