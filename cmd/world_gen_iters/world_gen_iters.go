package main

import (
	"log"
	"os"
	"text/template"
)

const ITERATOR_FUNCTION_TEMPLATE = `// Code generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	"iter"
	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
)
{{ range .Iterators }}
func (world *World) {{ .MethodName }}() iter.Seq2[scene.Handle, {{.TypeName}}] {
	return func(yield func(scene.Handle, {{.TypeName}}) bool) {
		{{- range .StorageNames}}
		next{{.}}, stop := iter.Pull2(world.{{.}}.All())
		defer stop()
		for handle, ent, ok := next{{.}}(); ok; handle, ent, ok = next{{.}}() {
			if !yield(handle, ent) {
				return
			}
		}
		{{- end }}
	}
}
{{ end }}`

type IterParams struct {
	TypeName     string // Must be qualified with the package name
	MethodName   string
	StorageNames []string
}

const WORLD_PKG = "world"
const SCENE_PKG = "scene"
const OUT_PATH = "./world_iterators.go" // This will be relative to the file in which the go:generate comment is.

func main() {
	iterators := []IterParams{
		{
			TypeName: "comps.HasBody", MethodName: "AllBodies",
			StorageNames: []string{
				"Players", "Enemies", "Chickens", "Walls", "Props", "Projectiles", "Items", "GameMap",
			},
		},
		{
			TypeName: "HasActor", MethodName: "AllActors",
			StorageNames: []string{
				"Players", "Enemies", "Chickens",
			},
		},
		{
			TypeName: "Linkable", MethodName: "AllLinkables",
			StorageNames: []string{
				"Triggers", "Cameras",
			},
		},
	}

	// Create output file
	outFile, err := os.Create(OUT_PATH)
	if err != nil {
		log.Fatal(err)
	}

	// Run the template on the collected data
	tmpl := template.Must(template.New("WORLD ITERATOR").Parse(ITERATOR_FUNCTION_TEMPLATE))

	tplParams := struct {
		Iterators []IterParams
	}{
		Iterators: iterators,
	}

	err = tmpl.Execute(outFile, tplParams)
	if err != nil {
		log.Fatal(err)
	}

	defer outFile.Close()
}
