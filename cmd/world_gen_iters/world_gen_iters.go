package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path"
	"reflect"
	"strings"
	"text/template"

	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
	"tophatdemon.com/total-invasion-ii/game/world"
)

const ITERATOR_FUNCTION_TEMPLATE = `// Code is generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	"tophatdemon.com/total-invasion-ii/engine/scene"
	"tophatdemon.com/total-invasion-ii/engine/scene/comps"
)
{{ range .Iterators }}

{{- $iterName := (print .PluralName "Iter") -}}

type {{ $iterName }} struct {
	{{- range .Stores }}
	iter{{ .Name }} scene.StorageIter[{{ .ElemType }}]
	{{- end }}
	storageIndex int
}

func (iter *{{ $iterName }}) Next() ({{ .Interface }}, scene.Handle) {
	if iter == nil {
		return nil, scene.Handle{}
	}
	for ; iter.storageIndex < {{ len .Stores }}; iter.storageIndex++ {
		switch iter.storageIndex {
			{{- range $idx, $store := .Stores }}
			case {{ $idx }}:
				item, handle := iter.iter{{ $store.Name }}.Next()
				if item != nil {
					return item, handle
				}
			{{- end }}
		}
	}
	return nil, scene.Handle{}
}

func (world *World) Iter{{ .PluralName }}() {{ $iterName }} {
	return {{ $iterName }} {
		{{- range .Stores }}
		iter{{ .Name }}: world.{{ .Name }}.Iter(),
		{{- end}}
		storageIndex: 0,
	}
}
{{ end }}`

type StorageInfo struct {
	Name     string
	ElemType string
}

type IterParams struct {
	Interface  string // Must be qualified with the package name
	PluralName string
	Stores     []StorageInfo
}

const WORLD_PKG = "world"
const SCENE_PKG = "scene"
const OUT_PATH = "./world_iterators.go" // This will be relative to the file in which the go:generate comment is.

var verboseFlag bool

func verbosePrintfln(format string, payload ...any) {
	if verboseFlag {
		fmt.Printf(format, payload...)
		fmt.Println()
	}
}

func genIterParamsFor[Interface any](pluralName string) (params IterParams) {
	worldType := reflect.TypeFor[world.World]()
	interfaceType := reflect.TypeFor[Interface]()
	storageOpsType := reflect.TypeFor[scene.StorageOps]()

	params = IterParams{
		PluralName: pluralName,
		Stores:     make([]StorageInfo, 0, worldType.NumField()),
		Interface:  qualifyTypeName(interfaceType),
	}

	// Find storage fields in the world struct whose inner types implement the interface.
	for f := range worldType.NumField() {
		field := worldType.Field(f)
		if !reflect.PointerTo(field.Type).Implements(storageOpsType) {
			verbosePrintfln("Field %v doesn't implement StorageOps\n", field.Name)
			continue
		}
		storageImplements := reflect.PointerTo(field.Type).Implements(interfaceType) // True if the storage itself is a member of the interface, like with GameMap
		if !storageImplements {
			if !strings.HasPrefix(field.Type.Name(), "Storage") {
				verbosePrintfln("Field %v is not a scene.Storage type. It's type is '%v'\n", field.Name, field.Type.Name())
				continue
			}

			// Get the storage struct's type parameter by looking at its data field.
			dataField, ok := field.Type.FieldByName("data")
			// Check if the pointer to the element type of the slice is a member of the interface.
			if !ok {
				verbosePrintfln("Field %v does not have a data field\n", field.Name)
				continue
			}

			if dataField.Type.Kind() != reflect.Slice {
				verbosePrintfln("Field %v's data field is not a slice, it has reflect.Kind = %v\n", field.Name, dataField.Type.Kind())
				continue
			}

			if !reflect.PointerTo(dataField.Type.Elem()).Implements(interfaceType) {
				verbosePrintfln("Field %v's data element does not implement the interface %v\n", field.Name, interfaceType.Name())
				continue
			}

			params.Stores = append(params.Stores, StorageInfo{
				Name:     field.Name,
				ElemType: qualifyTypeName(dataField.Type.Elem()),
			})
		} else {
			verbosePrintfln("Field %v is itself a member of the interface %v\n", field.Name, interfaceType.Name())
			params.Stores = append(params.Stores, StorageInfo{
				Name:     field.Name,
				ElemType: qualifyTypeName(field.Type),
			})
		}
	}

	return
}

func qualifyTypeName(typ reflect.Type) string {
	pkgName := path.Base(typ.PkgPath())
	if pkgName == "world" {
		return typ.Name()
	}
	return pkgName + "." + typ.Name()
}

func main() {
	flag.BoolVar(&verboseFlag, "verbose", false, "Print debug information about which fields get included in iterators.")
	flag.Parse()

	iterators := []IterParams{
		genIterParamsFor[comps.HasBody]("Bodies"),
		genIterParamsFor[world.HasActor]("Actors"),
		genIterParamsFor[world.Linkable]("Linkables"),
	}

	// Create output file
	outFile, err := os.Create(OUT_PATH)
	if err != nil {
		log.Fatal(err)
	}

	// Run the template on the collected data
	tmpl := template.Must(template.New("WORLD ITERATOR").Parse(ITERATOR_FUNCTION_TEMPLATE))

	tplParams := struct {
		Iterators []IterParams
	}{
		Iterators: iterators,
	}

	err = tmpl.Execute(outFile, tplParams)
	if err != nil {
		log.Fatal(err)
	}

	defer outFile.Close()
}
