package main

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"path"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const ITERATOR_FUNCTION_TEMPLATE = `// Code generated by world_gen_iters.go; DO NOT EDIT!
package world

import (
	{{- range .Packages }}
	"{{ . }}"
	{{- end }}
)
{{ range .Interfaces }}
func (world *World) {{ .MethodName }}Iter() func() ({{ .QualifiedName }}, scene.Handle) {
	{{- range .StorageNames }}
	iter{{ . }} := world.{{ . }}.Iter()
	{{- end }}
	return func() ({{ .QualifiedName }}, scene.Handle) {
		{{- range .StorageNames }}
		if item, id := iter{{ . }}(); item != nil {
			return item, id
		}
		{{- end }}
		return nil, scene.Handle{}
	}
}
{{ end }}`

type InterfaceTplParams struct {
	Package             string
	QualifiedName, Name string
	MethodName          string
	StorageNames        []string
}

const WORLD_PKG = "world"
const SCENE_PKG = "scene"
const PKG_PREFIX = "tophatdemon.com/total-invasion-ii"
const OUT_PATH = "./world_iterators.go" // This will be relative to the file in which the go:generate comment is.

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Supply import paths as arguments followed by .[InterfaceName]\n")
		os.Exit(1)
	}

	workingDirectory, _ := os.Getwd()
	fmt.Println("Working directory: ", workingDirectory)

	worldPkgPath := path.Join(PKG_PREFIX, "game", WORLD_PKG)
	scenePkgPath := path.Join(PKG_PREFIX, "engine", SCENE_PKG)
	pkgPaths := []string{worldPkgPath, scenePkgPath}

	interfaceArgs := os.Args[1:]
	interfaceParams := make([]InterfaceTplParams, len(interfaceArgs))

interfaceLoop:
	for i, arg := range interfaceArgs {
		interfaceParams[i].QualifiedName = path.Base(arg)
		dotPos := strings.LastIndexByte(arg, '.')
		if dotPos < 0 {
			interfaceParams[i].Package = worldPkgPath
			interfaceParams[i].Name = interfaceParams[i].QualifiedName
		} else {
			interfaceParams[i].Package = path.Join(PKG_PREFIX, strings.TrimSuffix(arg, arg[dotPos:]))
			interfaceParams[i].Name = arg[dotPos+1:]
		}
		interfaceParams[i].MethodName = strings.TrimPrefix(interfaceParams[i].Name, "Has")

		// Ensure the pkgPaths contains unique entries
		for _, pth := range pkgPaths {
			if pth == interfaceParams[i].Package {
				continue interfaceLoop
			}
		}
		pkgPaths = append(pkgPaths, interfaceParams[i].Package)
	}

	// Parse packages
	pkgConf := &packages.Config{Mode: packages.NeedSyntax | packages.NeedTypes | packages.NeedFiles | packages.NeedName}
	pkgs, err := packages.Load(pkgConf, pkgPaths...)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not load packages: %v\n", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	// Sort out world and scene package from other packages
	var worldPkg, scenePkg *packages.Package
	interfacePkgs := make([]*packages.Package, len(interfaceParams))
	for _, pkg := range pkgs {
		fmt.Printf("Found package %v.\n", pkg.Name)
		if pkg.Name == WORLD_PKG {
			worldPkg = pkg
		} else if pkg.Name == SCENE_PKG {
			scenePkg = pkg
		}
		for p, params := range interfaceParams {
			if params.Package == pkg.PkgPath {
				interfacePkgs[p] = pkg
			}
		}
	}
	if worldPkg == nil {
		fmt.Fprintf(os.Stderr, "Could not find world package!\n")
		os.Exit(1)
	}
	for p, pkg := range interfacePkgs {
		if pkg == nil {
			fmt.Fprintf(os.Stderr, "Interface package %v not found!\n", interfaceParams[p].Package)
			os.Exit(1)
		}
	}

	// Extract the World struct
	worldStruct := worldPkg.Types.Scope().Lookup("World").Type().Underlying().(*types.Struct)

	// Extract the StorageOps interface
	storageIntf := scenePkg.Types.Scope().Lookup("StorageOps").Type().Underlying().(*types.Interface)
	storageStructType := scenePkg.Types.Scope().Lookup("Storage").Type().(*types.Named)

	// For each interface collect a list of World Storage fields that implement them
	for f := range worldStruct.NumFields() {
		field := worldStruct.Field(f)
		if types.Implements(field.Type(), storageIntf) || types.Implements(types.NewPointer(field.Type()), storageIntf) {
			fmt.Printf("Found storage field %v...\n", field.Name())
			for i, iPkg := range interfacePkgs {
				// See if the storage itself implements the interface (as in GameMap)
				intf := iPkg.Types.Scope().Lookup(interfaceParams[i].Name).Type().Underlying().(*types.Interface)
				if types.Implements(field.Type(), intf) || types.Implements(types.NewPointer(field.Type()), intf) {
					interfaceParams[i].StorageNames = append(interfaceParams[i].StorageNames, field.Name())
					continue
				}

				// Otherwise see if the storage's generic type parameter implements it
				fieldNamedType := field.Type().(*types.Named)
				if types.Identical(fieldNamedType.Origin(), storageStructType) {
					typeParams := fieldNamedType.TypeArgs()
					if typeParams.Len() > 0 {
						innerType := typeParams.At(0)
						if types.Implements(innerType, intf) || types.Implements(types.NewPointer(innerType), intf) {
							interfaceParams[i].StorageNames = append(interfaceParams[i].StorageNames, field.Name())
						}
					}
				}
			}
		}
	}

	// Create output file
	outFile, err := os.Create(OUT_PATH)
	if err != nil {
		log.Fatal(err)
	}

	// Run the template on the collected data
	tmpl := template.Must(template.New("WORLD ITERATOR").Parse(ITERATOR_FUNCTION_TEMPLATE))

	tplParams := struct {
		Packages   []string
		Interfaces []InterfaceTplParams
	}{
		Packages:   pkgPaths[1:], // Exclude the world package because we're in it already
		Interfaces: interfaceParams,
	}

	err = tmpl.Execute(outFile, tplParams)
	if err != nil {
		log.Fatal(err)
	}

	defer outFile.Close()
}
